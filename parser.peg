start = template

ws = sym:[ \n\r\t]* {sym.join('')}

oT =
  ws (!"\\" "{{")

cT =
  (!"\\" "}}")

marker = oT / (([%@<>\+\?\:\!])? cT)

nM =
  !marker sym:. {return sym}

oP =
  ws (!"\\" "(") { return "("}

cP =
  ws (!"\\" ")") {return ")"}

nP =
  sym:(!(oP/cP) .) {return sym[1]}

any = /* Contains no markers.*/
  sym:nM+
  {var s = sym.join('');
    console.log('any: ('+(typeof s)+')',s);
    return s;
  }

content = sym:any & {return sym.replace(/\s+/,'')}
  { return sym }

output = sym:content {return 'out += "' + sym.replace(/[\r\n]/g, '\\n').replace('"', '\\"') + '";\n'}

parenthetical =
  ws sym:("(" (!marker c:(parenthetical/nP) { return c})* ")") { return sym.join('') }

identifier =
  ws sym:[a-zA-Z_]+ { return sym.join('') }

sig =
  "(" first:identifier? others:(ws "," identifier)* ")"
  {return '(' + (first ? [first].concat(others.map(function(e){return e[1]})) : []) + ')'}

template =
  oT "%" ws name:identifier? sig:sig
    body:(block/yield)* 
  ws "%"? cT ws
  {var f ='function *' + (name ? name : '') +sig +'{\n'
      + '  var out = "";'
      +    (body.length ? body.join('') : '')
      + '}\n';
    f.kataname = name;
    return f;
  }

iterate =
  oT "@" expr:parenthetical sig:sig
    body:block* 
  ws "@"? cT
  {return 'eval(' + expr.reduce(function(o,i){return o.concat(i)}, []).join('') + ').forEach(function' +sig + '{\n'
    + (body.length ? body.join('') : '')
    + '}\n';
  }

include =
  oT "+" alias:identifier expr:parenthetical
  ws "+"? cT
  {return 'var '+ alias + ' = require('+expr+');\n'}
 
invoke =
  oT ">" target:(identifier ws (parenthetical/("(" parenthetical (ws "," ws parenthetical)* ")" )))
    body:template*
  ws "<"? cT
  {var ret = '(function(){'
    +'  var gen = ' + target + ', step=gen.next();'
    +'  var mixins = {';

    body.forEach(function(f){
      ret += '"' + f.kataname + '": ' + f;
    });

    ret += '};'
    +'  while (!step.done){'
    +'    if (0 > mixins.indexOf(step.value)){'
    +'        mixins[step.value]();'
    +'        step = gen.throw(new Error("Extension not found"));'
    +'    }'
    +'    else step = gen.next();'
    +'  }'
    +'}());\n';

    return ret;
  }

yield =
  oT "<" mixin:identifier
    body:block*
  ws ">"? cT
  {return 'try {'
    +'  yield (' + mixin + ');'
    +'} catch (ex){'
    +   (body.length ? body.join('') : '')
    +'}\n';
  }

conditional =
  oT "?" expr:parenthetical
    body:(block/else)*
  ws "?"? cT
  {return 'if ('+expr+'){'
    + body.join('')
    + '}\n'
  }

else =
  oT ":" expr:parenthetical?
    body:block*
  ws ":"? cT
  {return /*{ needed for parser generator */
    '} else '+ (expr ? 'if ' + expr : '') + '{'
    + body.join('');
    /* needed for parser generator }*/
  }

interpolate =
  oT expr:content cT
  {return 'out += ' + expr + ';'}

evaluate =
  oT "!" expr:content "!"? cT
  {return expr}

block = template/iterate/invoke/include/conditional/evaluate/interpolate/output