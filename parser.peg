start = template

ws = sym:[ \n\r\t]* {sym.join('')}

oT =
  ws (!"\\" "{{")

cT =
  (!"\\" "}}")

marker = oT / (([%@<>\+\?\:\!])? cT)

nM =
  !marker sym:. {return sym}

oP =
  ws (!"\\" "(") { return "("}

cP =
  ws (!"\\" ")") {return ")"}

nP =
  sym:(!(oP/cP) .) {return sym[1]}

any = /* Contains no markers.*/
  sym:nM+
  {return sym.join(''); }

content = sym:any & {return sym.replace(/\s+/,'')}
  { return sym }

output = sym:content {return 'out += "' + sym.replace(/[\r\n]/g, '\\n').replace(/"/g, '\\"') + '";\n'}

parenthetical =
  ws ("(" sym:(!marker c:(parenthetical/nP) { return c})* ")") { return '(' + sym.join('') + ')' }

identifier =
  ws sym:[a-zA-Z_]+ { return sym.join('') }

sig =
  "(" first:identifier? others:(ws "," identifier)* ")"
  {return '(' + (first ? [first].concat(others.map(function(e){return e[1]})) : []) + ')'}

template =
  oT "%" ws name:identifier? sig:sig
    body:(block/yield)* 
  ws "%"? cT ws
  {var f ='function ' + (name ? name : '') +sig +'{\n'
      + '  var out = "";'
      +    (body.length ? body.join('') : '')
      + '  return out;'
      + '}\n';
    f.kataname = name;
    return f;
  }

iterate =
  oT "@" expr:parenthetical sig:sig
    body:block* 
  ws "@"? cT
  {return expr + '.forEach(function' +sig + '{\n'
    + (body.length ? body.join('') : '')
    + '}\n';
  }

include =
  oT "+" alias:identifier expr:parenthetical
  ws "+"? cT
  {return 'var '+ alias + ' = require('+expr+');\n'}
 
invoke =
  oT ">" target:identifier ws sig:parenthetical
    body:template*
  ws "<"? cT
  {var ret = 'out += ' + target + '.bind({'
    + body.reduce(function(o,f){
        if (! f.kataname) return o;
        o.push(f.kataname + ': ' + f);
        return o;
      }, []). join(',');
    + '})' + sig + '\n';
  }

yield =
  oT "<" mixin:identifier
    body:block*
  ws ">"? cT
  {return 'if (this.' + mixin + ') out+=this.'+mixin+'(); else {'
  + body.join(',')
  + '}\n'}

conditional =
  oT "?" expr:parenthetical
    body:(elseif/block)*
  ws "?"? cT
  {return 'if '+expr+'{'
    + (body.length ? '\n' : '')
    + body.join('')
    + '}\n'
  }

elseif =
  oT ":" expr:parenthetical?
    body:block*
  ws ":"? cT
  {return /*{ needed for parser generator */
    '} else '+ (expr ? 'if ' + expr : '') + '{'
    + body.join('');
    /* needed for parser generator }*/
  }

interpolate =
  oT expr:content cT
  {return 'out += (' + expr + ').replace(/"/g, \'\\"\');'}

evaluate =
  oT "!" expr:content "!"? cT
  {return expr}

block = template/iterate/invoke/include/conditional/evaluate/interpolate/output