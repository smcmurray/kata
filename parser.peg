start = template

oT =
  ws* (!"\\" "{{")

cT =
 (!"\\" "}}") ws*

marker = oT / (([%@<>\+\?\:\!])? cT)

content = sym:(!marker .)+ & {return sym.reduce(function(o,i){return o.concat(i)}, []).join('').replace(/\s+/,'')}
  { return sym.reduce(function(o,i){return o.concat(i)}, []).join('') }

output = sym:content {return 'out += "' + sym.replace(/[\r\n]/g, '\\n') + '";\n'}

template =
  oT "%" ws* name:identifier? sig:sig
    body:(block/yield)* 
  ws* "%"? cT
  {var f ='function *' + (name ? name : '') +sig +'{\n'
      + '  var out = "";'
      +    (body.length ? body.join('') : '')
      + '}\n';
    f.kataname = name;
    return f;
  }

iterate =
  oT "@" expr:parenthetical sig:sig
    body:block* 
  ws* "@"? cT
  {return 'eval(' + expr.reduce(function(o,i){return o.concat(i)}, []).join('') + ').forEach(function' +sig + '{\n'
    + (body.length ? body.join('') : '')
    + '}\n';
  }

include =
  oT "+" alias:identifier expr:parenthetical
  ws* "+"? cT
  {return 'var '+ alias + ' = require('+expr+');\n'}
 
invoke =
  oT ">" target:(identifier ws* (parenthetical/("(" parenthetical (ws* "," ws* parenthetical)* ")" )))
    body:template*
  ws* "<"? cT
  {var ret = '(function(){'
    +'  var gen = ' + target + ', step=gen.next();'
    +'  var mixins = {';

    body.forEach(function(f){
      ret += '"' + f.kataname + '": ' + f;
    });

    ret += '};'
    +'  while (!step.done){'
    +'    if (0 > mixins.indexOf(step.value)){'
    +'        mixins[step.value]();'
    +'        step = gen.throw(new Error("Extension not found"));'
    +'    }'
    +'    else step = gen.next();'
    +'  }'
    +'}());\n';

    return ret;
  }

yield =
  oT "<" mixin:identifier
    body:block*
  ws* ">"? cT
  {return 'try {'
    +'  yield (' + mixin + ');'
    +'} catch (ex){'
    +   (body.length ? body.join('') : '')
    +'}\n';
  }

conditional =
  oT "?" expr:parenthetical
    body:(block/else)*
  ws* "?"? cT
  {return 'if ('+expr+'){'
    + body.join('')
    + '}\n'
  }

else =
  oT ":" expr:parenthetical?
    body:block*
  ws* ":"? cT
  {return /*{ needed for parser generator */
    '} else '+ (expr ? 'if ' + expr : '') + '{'
    + body.join('');
    /* needed for parser generator }*/
  }

interpolate =
  oT expr:content cT
  {return 'out += ' + expr + ';'}

evaluate =
  oT "!" expr:content "!"? cT
  {return expr}

block = template/iterate/invoke/include/conditional/evaluate/interpolate/output

identifier =
  ws* sym:[a-zA-Z_]+ ws* { return sym.join('') }

ws = [ \n\r\t]

sig =
  "(" first:identifier? others:(ws* "," identifier)* ")"
  {return '(' + (first ? [first].concat(others.map(function(e){return e[1]})) : []) + ')'}

parenthetical =
  ws* "(" (content/parenthetical)? ")"